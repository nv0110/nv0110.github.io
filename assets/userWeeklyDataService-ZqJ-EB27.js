const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-B71EDpPb.js","assets/vendor-ui-aK89YfOw.js","assets/vendor-router-Cg8TMqY4.js","assets/vendor-react-eWEExxYH.js","assets/vendor-supabase-B7S7y5aO.js","assets/index-Bc7RTHCf.css"])))=>i.map(i=>d[i]);
import{_ as U}from"./vendor-supabase-B7S7y5aO.js";import{getCurrentMapleWeekStartDate as W}from"./mapleWeekUtils-Bm65Nri8.js";import{l as c}from"./index-B71EDpPb.js";import"./vendor-react-eWEExxYH.js";import"./vendor-ui-aK89YfOw.js";import"./vendor-router-Cg8TMqY4.js";async function v(){const{supabase:s}=await U(async()=>{const{supabase:t}=await import("./index-B71EDpPb.js").then(r=>r.m);return{supabase:t}},__vite__mapDeps([0,1,2,3,4,5]));return s}async function m(s,t){if(!s||!t)return c.error("fetchUserWeeklyData: Missing required parameters",{userId:s,mapleWeekStart:t}),{success:!1,error:"Missing required parameters."};try{const r=await v();c.info("fetchUserWeeklyData: Querying database",{userId:s,mapleWeekStart:t,queryTable:"user_boss_data",queryColumns:"user_id, maple_week_start"});const{data:e,error:a}=await r.from("user_boss_data").select("*").eq("user_id",s).eq("maple_week_start",t);if(c.info("fetchUserWeeklyData: Database query result",{hasData:!!e,hasError:!!a,errorCode:a==null?void 0:a.code,errorMessage:a==null?void 0:a.message,dataLength:Array.isArray(e)?e.length:e?1:0,rawData:e}),a)return c.error("fetchUserWeeklyData: Database error",a),{success:!1,error:"Failed to fetch weekly data."};const o=Array.isArray(e)?e.length>0?e[0]:null:e;return c.info("fetchUserWeeklyData: Processed result",{hasWeekData:!!o,originalDataType:Array.isArray(e)?"array":typeof e,resultKeys:o?Object.keys(o):null}),{success:!0,data:o}}catch(r){return c.error("fetchUserWeeklyData: Unexpected error",r),{success:!1,error:"Failed to fetch weekly data."}}}async function w(s,t,r){if(!s||!t||!r)return{success:!1,error:"Missing required parameters."};try{const e=await v(),a={user_id:s,maple_week_start:t,...r},o=await e.from("user_boss_data").select("user_id, maple_week_start").eq("user_id",s).eq("maple_week_start",t),u=await e.from("user_boss_data").select("user_id, maple_week_start").eq("user_id",s);o.error&&c.error("saveOrUpdateUserWeeklyData: Error checking existing record",o.error),c.info("saveOrUpdateUserWeeklyData: Record analysis",{targetWeek:t,hasExistingForWeek:o.data&&o.data.length>0,existingForWeekCount:o.data?o.data.length:0,allUserRecordsCount:u.data?u.data.length:0,allUserWeeks:u.data?u.data.map(l=>l.maple_week_start):[],operation:o.data&&o.data.length>0?"update":"insert"});let n;if(o.data&&o.data.length>0)c.info("saveOrUpdateUserWeeklyData: Updating existing record"),n=await e.from("user_boss_data").update(r).eq("user_id",s).eq("maple_week_start",t);else{if(u.data&&u.data.length>0){c.info(`saveOrUpdateUserWeeklyData: Database constraint issue detected - user has ${u.data.length} existing records, deleting and inserting`);const l=await e.from("user_boss_data").delete().eq("user_id",s);if(l.error)return c.error("saveOrUpdateUserWeeklyData: Failed to delete existing records",l.error),{success:!1,error:"Failed to clear existing data."};c.info("saveOrUpdateUserWeeklyData: Deleted existing records, now inserting new record")}c.info("saveOrUpdateUserWeeklyData: Inserting new record"),n=await e.from("user_boss_data").insert(a)}const{error:i}=n;return c.info("saveOrUpdateUserWeeklyData: Operation completed successfully",{operation:o.data&&o.data.length>0?"update":"insert",targetWeek:t,userId:s,charCount:Object.keys(r.char_map||{}).length,bossConfigCount:Object.keys(r.boss_config||{}).length,clearsCount:Object.keys(r.weekly_clears||{}).length}),i?(c.error("saveOrUpdateUserWeeklyData: Operation failed",i),{success:!1,error:"Failed to save weekly data."}):{success:!0}}catch(e){return c.error("Unexpected error saving user weekly data:",e),{success:!1,error:"Failed to save weekly data."}}}async function B(s,t,r){if(!s||!t||!(r!=null&&r.trim()))return{success:!1,error:"Missing required parameters."};try{const e=await m(s,t);if(!e.success)return{success:!1,error:e.error};const a=e.data||{char_map:{},boss_config:{},weekly_clears:{}},o=Object.keys(a.char_map||{}).map(f=>parseInt(f)),u=o.length>0?Math.max(...o)+1:0,n=u.toString();if(Object.values(a.char_map||{}).some(f=>f.toLowerCase()===r.trim().toLowerCase()))return{success:!1,error:`Character name '${r.trim()}' already exists.`};const l={...a.char_map},d={...a.boss_config},g={...a.weekly_clears};l[n]=r.trim(),d[n]="",g[n]="";const h=await w(s,t,{char_map:l,boss_config:d,weekly_clears:g});return h.success?{success:!0,characterIndex:u}:{success:!1,error:h.error}}catch(e){return c.error("Unexpected error adding character:",e),{success:!1,error:"Failed to add character."}}}async function j(s,t,r){if(!s||!t||r===void 0)return{success:!1,error:"Missing required parameters."};try{const e=await m(s,t);if(!e.success)return{success:!1,error:e.error};if(!e.data)return{success:!1,error:"No weekly data found."};const a=e.data,o=r.toString();if(!(o in(a.char_map||{})))return{success:!1,error:"Character not found."};const u={...a.char_map},n={...a.boss_config},i={...a.weekly_clears};delete u[o],delete n[o],delete i[o];const l=await w(s,t,{char_map:u,boss_config:n,weekly_clears:i});return l.success?{success:!0}:{success:!1,error:l.error}}catch(e){return c.error("Unexpected error removing character:",e),{success:!1,error:"Failed to remove character."}}}async function S(s,t,r,e){if(!s||!t||r===void 0||!(e!=null&&e.trim()))return{success:!1,error:"Missing required parameters."};try{const a=await m(s,t);if(!a.success)return{success:!1,error:a.error};if(!a.data)return{success:!1,error:"No weekly data found."};const o=a.data,u=r.toString();if(!(u in(o.char_map||{})))return{success:!1,error:"Character not found."};if(Object.entries(o.char_map||{}).filter(d=>d[0]!==u).map(d=>d[1]).some(d=>d.toLowerCase()===e.trim().toLowerCase()))return{success:!1,error:`Character name '${e.trim()}' already exists.`};const i={...o.char_map};i[u]=e.trim();const l=await w(s,t,{char_map:i,boss_config:o.boss_config||{},weekly_clears:o.weekly_clears||{}});return l.success?{success:!0}:{success:!1,error:l.error}}catch(a){return c.error("Unexpected error updating character name:",a),{success:!1,error:"Failed to update character name."}}}async function A(s,t,r,e){if(!s||!t||r===void 0)return{success:!1,error:"Missing required parameters."};try{if(e&&e.trim()){const l=await x(e);if(!l.success)return{success:!1,error:l.error}}const a=await m(s,t);if(!a.success)return{success:!1,error:a.error};if(!a.data)return{success:!1,error:"No weekly data found."};const o=a.data,u=r.toString();if(!(u in(o.char_map||{})))return{success:!1,error:"Character not found."};const n={...o.boss_config};n[u]=e||"";const i=await w(s,t,{char_map:o.char_map||{},boss_config:n,weekly_clears:o.weekly_clears||{}});return i.success?{success:!0}:{success:!1,error:i.error}}catch(a){return c.error("Unexpected error updating boss config:",a),{success:!1,error:"Failed to update boss configuration."}}}async function x(s){if(!s||typeof s!="string")return{success:!0};try{const t=await v(),{data:r,error:e}=await t.from("boss_registry").select("boss_code, difficulty_code, crystal_value, max_party_size, enabled");if(e)return c.error("Error fetching boss registry:",e),{success:!1,error:"Failed to validate boss configuration."};const a=s.split(",");for(const o of a){const u=o.split(":");if(u.length!==3)return{success:!1,error:`Invalid boss config format: ${o}`};const[n,i,l]=u,d=parseInt(i),g=parseInt(l),h=r.find(f=>`${f.boss_code}-${f.difficulty_code}`===n||f.boss_code===n);if(!h)return{success:!1,error:`Unknown boss code: ${n}`};if(!h.enabled)return{success:!1,error:`Boss ${n} is not enabled.`};if(d!==h.crystal_value&&c.warn(`Crystal value mismatch for ${n}. Expected: ${h.crystal_value}, got: ${d}. Using database value.`),g<1||g>h.max_party_size)return{success:!1,error:`Invalid party size for ${n}. Must be between 1 and ${h.max_party_size}.`}}return{success:!0}}catch(t){return c.error("Unexpected error validating boss config:",t),{success:!1,error:"Failed to validate boss configuration."}}}async function T(s){const t=W();c.info(`fetchCurrentWeekData: Starting for user ${s}, current week start: ${t}`);const r=await m(s,t);if(c.info("fetchCurrentWeekData: Current week query result",{success:r.success,hasData:!!r.data,error:r.error,data:r.data}),!r.success)return c.error("fetchCurrentWeekData: Failed to fetch current week data",r.error),r;if(r.data)return c.info(`fetchCurrentWeekData: Found existing data for current week ${t}`,{charCount:r.data.char_map?Object.keys(r.data.char_map).length:0,charMap:r.data.char_map,bossConfig:r.data.boss_config}),r;try{c.info(`fetchCurrentWeekData: No data found for current week ${t}, checking previous week`);const e=new Date(t+"T00:00:00.000Z"),a=new Date(e);a.setUTCDate(e.getUTCDate()-7);const o=a.getUTCFullYear()+"-"+String(a.getUTCMonth()+1).padStart(2,"0")+"-"+String(a.getUTCDate()).padStart(2,"0");c.info(`fetchCurrentWeekData: Checking previous week ${o} for user ${s}`);const u=await m(s,o);if(!u.success)return c.info(`fetchCurrentWeekData: Failed to fetch previous week data: ${u.error}`),{success:!0,data:null};if(!u.data)return c.info("fetchCurrentWeekData: No previous week data found either"),{success:!0,data:null};const n=u.data;if(!n.char_map||Object.keys(n.char_map).length===0)return c.info("fetchCurrentWeekData: Previous week data exists but has no characters"),{success:!0,data:null};c.info(`fetchCurrentWeekData: Migrating ${Object.keys(n.char_map).length} characters from ${o} to ${t} for user ${s}`,{previousCharMap:n.char_map,previousBossConfig:n.boss_config,previousWeeklyClears:n.weekly_clears});const i={char_map:n.char_map,boss_config:n.boss_config||{},weekly_clears:{}};Object.keys(i.char_map).forEach(g=>{i.weekly_clears[g]=""}),c.info("fetchCurrentWeekData: Prepared migration data",{migratedCharMap:i.char_map,migratedBossConfig:i.boss_config,migratedWeeklyClears:i.weekly_clears});const l=await m(s,t);if(l.success&&l.data)return c.info("fetchCurrentWeekData: Current week data appeared during migration, using existing data"),l;const d=await w(s,t,i);if(!d.success){c.error(`fetchCurrentWeekData: Failed to save migrated data for user ${s}: ${d.error}`);const g=await m(s,t);return g.success&&g.data?(c.info("fetchCurrentWeekData: Found data after failed migration - using existing data"),g):(c.error("fetchCurrentWeekData: Migration completely failed - returning previous week data as fallback"),{success:!0,data:n})}return c.info(`fetchCurrentWeekData: Successfully migrated data for user ${s} from ${o} to ${t}`),{success:!0,data:i}}catch(e){return c.error("fetchCurrentWeekData: Error during weekly data migration:",e),{success:!1,error:"Failed to check for previous week data."}}}async function P(s,t){const r=W();return await w(s,r,t)}async function $(s,t,r,e){try{if(!s||!t||r===void 0)return{success:!1,error:"Missing required parameters: userId, mapleWeekStart, and characterIndex"};if(e&&e.trim()){const d=e.split(",").map(g=>g.trim()).filter(g=>g);if(d.length>0){const g=await v();if(d.every(f=>/^\d+$/.test(f))){const f=d.map(b=>parseInt(b)),{data:y,error:p}=await g.from("boss_registry").select("id").in("id",f);if(p)throw p;const _=new Set(y.map(b=>b.id)),k=f.filter(b=>!_.has(b));if(k.length>0)return{success:!1,error:`Invalid boss registry IDs: ${k.join(", ")}`}}else{const{data:f,error:y}=await g.from("boss_registry").select("id").in("id",d);if(y)throw y;const p=new Set(f.map(k=>k.id)),_=d.filter(k=>!p.has(k));if(_.length>0)return{success:!1,error:`Invalid boss codes: ${_.join(", ")}`}}}}const a=await m(s,t);if(!a.success)return a;const o=a.data;if(!o)return{success:!1,error:"No weekly data found. Please add characters first."};if(!(o.char_map||{})[r])return{success:!1,error:`Character at index ${r} not found`};const i={weekly_clears:{...o.weekly_clears||{},[r]:e||""}};return await w(s,t,i)}catch(a){return c.error("Error updating character weekly clears:",a),{success:!1,error:a.message}}}async function L(s,t,r,e,a){try{if(!s||!t||r===void 0||!e||a===void 0)return{success:!1,error:"Missing required parameters"};const o=await v(),{data:u,error:n}=await o.from("boss_registry").select("id, boss_name, difficulty").eq("id",e).single();if(n){if(n.code==="PGRST116")return{success:!1,error:`Invalid boss registry ID: ${e}`};throw n}const i=await m(s,t);if(!i.success)return i;const l=i.data;if(!l)return{success:!1,error:"No weekly data found. Please add characters first."};if(!(l.char_map||{})[r])return{success:!1,error:`Character at index ${r} not found`};const g=l.weekly_clears||{},f=(g[r]||"").split(",").map(C=>C.trim()).filter(C=>C),y=e.toString();let p;a?f.includes(y)?p=f:p=[...f,y]:p=f.filter(C=>C!==y);const k={weekly_clears:{...g,[r]:p.join(",")}};return await w(s,t,k)}catch(o){return c.error("Error toggling boss clear status:",o),{success:!1,error:o.message}}}async function z(s,t,r){try{return await $(s,t,r,"")}catch(e){return c.error("Error clearing all bosses for character:",e),{success:!1,error:e.message}}}async function N(s,t,r){try{if(!s||!t||r===void 0)return{success:!1,error:"Missing required parameters"};const e=await m(s,t);if(!e.success)return e;const a=e.data;if(!a)return{success:!1,error:"No weekly data found. Please add characters first."};if(!(a.char_map||{})[r])return{success:!1,error:`Character at index ${r} not found`};const n=(a.boss_config||{})[r]||"";if(!n)return{success:!1,error:"No boss configuration found for this character"};const{parseBossConfigString:i}=await U(async()=>{const{parseBossConfigString:p}=await import("./mapleWeekUtils-Bm65Nri8.js");return{parseBossConfigString:p}},[]),l=i(n),d=await v(),{data:g,error:h}=await d.from("boss_registry").select("*");if(h)throw h;const f=[];for(const p of l){const _=p.bossCode.split("-"),k=_[0],b=_[1],C=g.find(D=>D.boss_code===k&&D.difficulty_code===b);C?f.push(C.id):c.warn(`Boss registry entry not found for boss code: ${p.bossCode}`)}const y=f.join(",");return await $(s,t,r,y)}catch(e){return c.error("Error marking all bosses for character:",e),{success:!1,error:e.message}}}async function V(s,t,r){if(!s||!t||!Array.isArray(r))return{success:!1,error:"Missing required parameters."};try{const e=await m(s,t);if(!e.success)return{success:!1,error:e.error};const a=e.data||{char_map:{},boss_config:{},weekly_clears:{}},o=a.char_map||{},u=a.boss_config||{},n=a.weekly_clears||{},i=Object.values(o);for(const f of r)if(!i.includes(f))return{success:!1,error:`Character '${f}' not found in current data.`};if(i.length!==r.length)return{success:!1,error:"New character order must include all existing characters."};const l={},d={},g={};r.forEach((f,y)=>{const p=y.toString(),_=Object.keys(o).find(k=>o[k]===f);_&&(l[p]=f,d[p]=u[_]||"",g[p]=n[_]||"")});const h=await w(s,t,{char_map:l,boss_config:d,weekly_clears:g});return h.success?(c.info("Successfully reordered characters in weekly setup",{userId:s,mapleWeekStart:t,oldOrder:i,newOrder:r}),{success:!0}):{success:!1,error:h.error}}catch(e){return c.error("Unexpected error reordering characters:",e),{success:!1,error:"Failed to reorder characters."}}}export{B as addCharacterToWeeklySetup,z as clearAllBossesForCharacter,T as fetchCurrentWeekData,m as fetchUserWeeklyData,N as markAllBossesForCharacter,j as removeCharacterFromWeeklySetup,V as reorderCharactersInWeeklySetup,P as saveCurrentWeekData,w as saveOrUpdateUserWeeklyData,L as toggleBossClearStatus,A as updateCharacterBossConfigInWeeklySetup,S as updateCharacterNameInWeeklySetup,$ as updateCharacterWeeklyClearsInWeeklySetup};
