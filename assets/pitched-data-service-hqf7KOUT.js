const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/supabaseClient-B7fnwhYs.js","assets/vendor-supabase-B7S7y5aO.js","assets/vendor-react-eWEExxYH.js","assets/Navbar-C88T-MOZ.js","assets/vendor-ui-DqxmAIBo.js","assets/vendor-router-BPn28yDh.js","assets/index-CFYAW1g3.js","assets/index-C9_Ifi-v.css"])))=>i.map(i=>d[i]);
import{_ as q}from"./vendor-supabase-B7S7y5aO.js";import{a as F}from"./Navbar-C88T-MOZ.js";import"./vendor-react-eWEExxYH.js";import"./vendor-ui-DqxmAIBo.js";import"./vendor-router-BPn28yDh.js";import"./index-CFYAW1g3.js";function C(){return F()}async function S(){const{supabase:r}=await q(async()=>{const{supabase:t}=await import("./supabaseClient-B7fnwhYs.js");return{supabase:t}},__vite__mapDeps([0,1,2]));return r}function M(r){if(!r)return null;try{const t=new Date(r),e=new Date(t.getUTCFullYear(),t.getUTCMonth(),t.getUTCDate()),c=new Date(e.getUTCFullYear(),0,1),n=Math.ceil(((e-c)/864e5+c.getUTCDay()+1)/7);return`${e.getUTCFullYear()}-${n}`}catch(t){return console.error("Error getting week key from date:",t),null}}async function Q(r,t){var e,c,n,l;try{console.log("saveBossRun called with:",{userCode:r,data:t});const{character:s,characterIdx:a,bossName:o,bossDifficulty:u,isCleared:f,date:h}=t;if(!r||!s||!o||!u||f===void 0)return console.error("Missing required fields:",{userCode:r,character:s,bossName:o,bossDifficulty:u,isCleared:f}),{success:!1,error:"Missing required fields"};const i=await S(),{data:y,error:m}=await i.from("user_data").select("*").eq("id",r).single();if(m)throw console.error("Error fetching user data:",m),m;if(!y)throw console.error("No user data found"),new Error("No user data found");const d=y.data?JSON.parse(JSON.stringify(y.data)):{};d.boss_runs?Array.isArray(d.boss_runs)||(console.log("boss_runs exists but is not an array, fixing this issue"),d.boss_runs=[]):(d.boss_runs=[],console.log("Initializing missing boss_runs array in data object"));const g=d.boss_runs,_=C();console.log(`Current boss runs count: ${g.length}`),console.log("Current data structure:",JSON.stringify(d,null,2)),console.log("🧹 CLEANUP: Checking for inconsistent boss_runs to remove...");const b=(d.characters||[]).find((w,K)=>w.name===s&&(w.index===a||K===a));if(b){console.log("🧹 CLEANUP: Found character data:",{name:b.name,bosses:((e=b.bosses)==null?void 0:e.map(E=>`${E.name}-${E.difficulty}`))||[]});const w=new Set;(c=b.bosses)==null||c.forEach(E=>{w.add(`${E.name}-${E.difficulty}`)}),console.log("🧹 CLEANUP: Valid boss combinations for character:",Array.from(w));const K=g.length,N=g.filter(E=>{if(E.character!==s||E.weekKey!==_)return!0;const x=`${E.boss}-${E.difficulty}`,T=w.has(x);return T||console.log(`🗑️ CLEANUP: Removing invalid boss_run: ${E.character}-${E.boss}-${E.difficulty} (not in selected bosses)`),T});d.boss_runs=N,K!==N.length?console.log(`🧹 CLEANUP: Removed ${K-N.length} invalid boss_runs`):console.log("🧹 CLEANUP: No invalid boss_runs found to remove")}else console.log("🧹 CLEANUP: Could not find character data for cleanup");const D=d.boss_runs,v=D.findIndex(w=>w.character===s&&w.boss===o&&w.difficulty===u&&w.weekKey===_);let k;if(f){const w={id:`${s}-${o}-${u}-${_}-${Date.now()}`,character:s,characterIdx:a||0,boss:o,difficulty:u,cleared:!0,date:h||new Date().toISOString(),weekKey:_};v!==-1?(k=[...D],k[v]={...k[v],cleared:!0,date:h||new Date().toISOString(),lastUpdated:new Date().toISOString()},console.log(`Updating existing boss run at index ${v}`)):(k=[...D,w],console.log(`Adding new boss run, total count will be ${k.length}`))}else v!==-1?(k=D.filter((w,K)=>K!==v),console.log(`Removing boss run at index ${v}, total count will be ${k.length}`)):(k=[...D],console.log("No existing boss run found to remove"));const U={...d,boss_runs:k,lastUpdated:new Date().toISOString()};console.log("About to save this data structure:",JSON.stringify({...U,boss_runs_count:k.length},null,2).substring(0,200)+"...");const A={...d,boss_runs:k,lastUpdated:new Date().toISOString()};console.log("SIMPLIFIED DATA STRUCTURE:",JSON.stringify(A).substring(0,200)+"..."),console.log("🚨 ATTEMPTING DATABASE UPDATE WITH BOSS RUNS ARRAY");const{data:$,error:I}=await i.from("user_data").update({data:A}).eq("id",r).select();if(console.log("UPDATE RESULT:",JSON.stringify($)),I)throw console.error("Database update error:",I),I;console.log(`Successfully ${f?"saved":"removed"} boss run for ${s} - ${o} ${u}. Cleared: ${f}`),console.log("🔍 VERIFYING DATABASE STATE WITH SEPARATE FETCH");const{data:p,error:P}=await i.from("user_data").select("*").eq("id",r).single();if(P)console.error("Verification fetch error:",P);else if(console.log("DATABASE ACTUAL STATE:",JSON.stringify(p).substring(0,200)+"..."),(n=p==null?void 0:p.data)!=null&&n.boss_runs)console.log(`✅ VERIFICATION SUCCESS: Database has ${p.data.boss_runs.length} boss runs`);else{console.log("❌ VERIFICATION FAILED: No boss_runs array found in database"),console.log("⚠️ Attempting UPSERT as a fallback...");const w={id:r,data:{...p.data,boss_runs:k,lastUpdated:new Date().toISOString()}},{error:K}=await i.from("user_data").upsert(w);if(K)console.error("Upsert failed:",K);else{console.log("✅ Upsert succeeded, verifying again...");const{data:N}=await i.from("user_data").select("*").eq("id",r).single();(l=N==null?void 0:N.data)!=null&&l.boss_runs?console.log(`✅✅ FINAL VERIFICATION: Database now has ${N.data.boss_runs.length} boss runs`):console.log("❌❌ FINAL VERIFICATION FAILED: Still no boss_runs array")}}return{success:!0,bossRuns:k,updatedData:U}}catch(s){return console.error("Error saving boss run:",s),{success:!1,error:s}}}async function X(r,t,e=!1,c=null){var n,l;try{console.log("savePitchedItem called with:",{userCode:r,data:t,remove:e,weekKey:c});const{character:s,bossName:a,itemName:o,itemImage:u,date:f,characterIdx:h,bossDifficulty:i}=t;if(!r||!s||!a||!o||!u)return console.error("Missing required fields:",{userCode:r,character:s,bossName:a,itemName:o,itemImage:u}),{success:!1,error:"Missing required fields"};console.log("Fetching user data for userCode:",r);const y=await S(),{data:m,error:d}=await y.from("user_data").select("pitched_items, data").eq("id",r).single();if(d)throw console.error("Error fetching user data:",d),d;const g=m.pitched_items||[],_=m.data||{},R=_.boss_runs||[],b=c||M(f)||C(),D=C(),v=b===D;if(v&&!e){console.log("🧹 PITCHED CLEANUP: Checking for inconsistent pitched items to remove...");const U=(_.characters||[]).find((A,$)=>A.name===s&&(A.index===h||$===h));if(U){console.log("🧹 PITCHED CLEANUP: Found character data:",{name:U.name,bosses:((n=U.bosses)==null?void 0:n.map(p=>`${p.name}-${p.difficulty}`))||[]});const A=new Set;(l=U.bosses)==null||l.forEach(p=>{A.add(`${p.name}-${p.difficulty}`)}),console.log("🧹 PITCHED CLEANUP: Valid boss combinations for character:",Array.from(A));const $=g.length,I=g.filter(p=>{if(p.character!==s||p.weekKey!==D)return!0;const P=`${p.boss}-${p.difficulty||"Unknown"}`,w=A.has(P);return w||console.log(`🗑️ PITCHED CLEANUP: Removing invalid current week pitched item: ${p.character}-${p.boss}-${p.difficulty||"Unknown"} - ${p.item}`),w});$!==I.length?(console.log(`🧹 PITCHED CLEANUP: Removed ${$-I.length} invalid pitched items`),g.length=0,g.push(...I)):console.log("🧹 PITCHED CLEANUP: No invalid pitched items found to remove")}else console.log("🧹 PITCHED CLEANUP: Could not find character data for cleanup")}if(e){console.log("Removing pitched item:",{character:s,bossName:a,itemName:o,weekKey:b});const k=g.filter($=>!($.character===s&&$.boss===a&&$.item===o&&$.weekKey===b));let U=_;if(v){const $=R.filter(I=>I.character===s&&I.boss===a&&I.weekKey===b&&I.hasPitchedItem===!0?(console.log(`Removing boss run with hasPitchedItem flag: ${I.boss} ${I.difficulty} for ${s}`),!1):!0);U={..._,boss_runs:$,lastUpdated:new Date().toISOString()}}const{error:A}=await y.from("user_data").update({pitched_items:k,...v&&{data:U}}).eq("id",r);if(A)throw A;return console.log(`Successfully removed pitched item for ${s} from ${a}. Remaining items: ${k.length}`),{success:!0}}else{const k={character:s,characterIdx:h||0,boss:a,difficulty:i,item:o,image:u,date:f||new Date().toISOString(),weekKey:b};if(g.find(p=>p.character===s&&p.boss===a&&p.item===o&&p.weekKey===b))return console.log("Item already exists in database, not adding duplicate"),{success:!0,alreadyExists:!0};const A=[...g,k];let $=_;if(v){let p=[...R];const P=R.findIndex(w=>w.character===s&&w.boss===a&&w.weekKey===b);if(P===-1){const E=H(a).sort((x,T)=>{const W={Extreme:5,Hard:4,Chaos:3,Normal:2,Easy:1},B=x.split("-")[1],O=T.split("-")[1];return(W[O]||0)-(W[B]||0)})[0].split("-")[1];p.push({character:s,characterIdx:h||0,boss:a,difficulty:E,cleared:!0,date:f||new Date().toISOString(),weekKey:b,hasPitchedItem:!0})}else p[P]={...p[P],hasPitchedItem:!0,date:f||new Date().toISOString()};$={..._,boss_runs:p,lastUpdated:new Date().toISOString()}}else console.log(`Historical pitched item for week ${b} - not modifying boss_runs`);const{error:I}=await y.from("user_data").update({pitched_items:A,...v&&{data:$}}).eq("id",r);if(I)throw I;if(console.log(`Successfully saved pitched item for ${s} from ${a} (week: ${b})`),v){const P=$.checked||{},w=`${s}-${h||0}`,K=H(a);let N=!1;if(P[w]){for(const E of K)if(P[w][E]){N=!0;break}}if(!N&&K.length>0){const x=K.sort((T,W)=>{const B={Extreme:5,Hard:4,Chaos:3,Normal:2,Easy:1},O=T.split("-")[1],L=W.split("-")[1];return(B[L]||0)-(B[O]||0)})[0];P[w]||(P[w]={}),P[w][x]=!0}}return{success:!0}}return console.log("Successfully updated pitched_items and synchronized with application data"),{success:!0,data:pitchedItem,updatedWeekKey:b}}catch(s){return console.error("Error saving pitched item:",s),{success:!1,error:s.message||"Unknown error occurred"}}}async function Z(r){var t;try{const e=await S(),{data:c,error:n}=await e.from("user_data").select("data").eq("id",r).single();if(n)throw n;return{success:!0,data:((t=c==null?void 0:c.data)==null?void 0:t.pitchedItems)||[]}}catch(e){return console.error("Error fetching pitched items:",e),{success:!1,error:e,data:[]}}}async function ee(r){try{const t=await S(),{data:e,error:c}=await t.from("user_data").select("pitched_items").eq("id",r).single();if(c)throw c;return{success:!0,items:(e==null?void 0:e.pitched_items)||[]}}catch(t){return console.error("Error fetching all pitched items:",t),{success:!1,error:t,items:[]}}}async function te(r,t=null){try{const e=await S(),{data:c,error:n}=await e.from("user_data").select("pitched_items").eq("id",r).single();if(n)throw n;const l=c.pitched_items||[],s={};return l.forEach(a=>{const o=new Date(a.date).getFullYear();t&&o!==parseInt(t)||(s[o]||(s[o]={total:0,characters:new Set,items:[]}),s[o].total+=1,s[o].characters.add(a.character),s[o].items.push({character:a.character,boss:a.boss,item:a.item,image:a.image,date:a.date}))}),Object.keys(s).forEach(a=>{s[a].characters=Array.from(s[a].characters)}),{success:!0,data:s}}catch(e){return console.error("Error fetching yearly pitched stats:",e),{success:!1,error:e,data:{}}}}async function se(r,t){try{const e=await S(),{data:c,error:n}=await e.from("user_data").select("pitched_items, data").eq("id",r).single();if(n)throw n;const l=c.pitched_items||[],s=c.data||{},a=s.boss_runs||[],o=C(),u=l.filter(y=>!t.some(m=>y.character===m.character&&y.boss===m.bossName&&y.item===m.itemName&&y.weekKey===m.weekKey)),f=t.filter(y=>y.weekKey===o);let h=s;if(f.length>0){const y=a.filter(m=>f.some(g=>m.character===g.character&&m.boss===g.bossName&&m.weekKey===g.weekKey&&m.hasPitchedItem===!0)?(console.log(`[Batch Removal] Removing boss run with hasPitchedItem flag: ${m.boss} ${m.difficulty} for ${m.character}`),!1):!0);h={...s,boss_runs:y,lastUpdated:new Date().toISOString()}}const{error:i}=await e.from("user_data").update({pitched_items:u,...f.length>0&&{data:h}}).eq("id",r);if(i)throw i;return console.log(`[Batch Removal] Successfully removed ${t.length} pitched items for user '${r}'. Remaining items: ${u.length}`),console.log("[Batch Removal] Items removed:",t),{success:!0}}catch(e){return console.error("Error removing many pitched items:",e),{success:!1,error:e}}}async function re(r){var t;try{const e=await S(),{data:c,error:n}=await e.from("user_data").select("data, pitched_items").eq("id",r).single();if(n)throw n;return{success:!0,export:{data:c.data,pitched_items:c.pitched_items,weekKey:((t=c.data)==null?void 0:t.weekKey)||C(),exportDate:new Date().toISOString()}}}catch(e){return console.error("Error exporting user data:",e),{success:!1,error:e}}}function H(r){const t=["Easy","Normal","Hard","Chaos","Extreme"];return({Lotus:["Easy","Normal","Hard","Extreme"],Damien:["Normal","Hard"],Will:["Easy","Normal","Hard"],Lucid:["Easy","Normal","Hard"],"Chosen Seren":["Normal","Hard","Extreme"],"Watcher Kalos":["Easy","Normal","Chaos","Extreme"],Kaling:["Easy","Normal","Hard","Extreme"],Limbo:["Normal","Hard"]}[r]||t).map(n=>`${r}-${n}`)}async function oe(r,t){var e;try{if(!t||typeof t!="object")throw new Error("Invalid import object");const{data:c,pitched_items:n,weekKey:l}=t,s=await S(),{data:a,error:o}=await s.from("user_data").select("data").eq("id",r).single();if(o&&o.code!=="PGRST116")throw o;const u=C(),f=(e=a==null?void 0:a.data)==null?void 0:e.weekKey;let h={...c};l&&l!==u&&(console.log(`[Import] Week key transition: ${l} -> ${u}`),h.weekKey=u);const{error:i}=await s.from("user_data").update({data:h,pitched_items:n}).eq("id",r);if(i)throw i;return console.log(`[Import] Successfully imported data for user '${r}'.`),{success:!0,data:h}}catch(c){return console.error("Error importing user data:",c),{success:!1,error:c}}}async function ae(r,t,e=0){try{if(console.log(`🗑️ Starting pitched records purge for character: ${t} (idx: ${e})`),!r||!t)return console.error("Missing required fields:",{userCode:r,characterName:t}),{success:!1,error:"Missing required fields"};const c=await S(),{data:n,error:l}=await c.from("user_data").select("data, pitched_items").eq("id",r).single();if(l)throw console.error("Error fetching user data:",l),l;const s=n.data||{},a=n.pitched_items||[],o=s.boss_runs||[],u=a.filter(d=>{const g=d.character===t&&(d.characterIdx===e||d.characterIndex===e);return g&&console.log(`🗑️ Removing pitched item: ${d.item} from ${d.boss} for ${t}`),!g}),f=o.filter(d=>{const g=d.character===t&&(d.characterIdx===e||d.characterIndex===e),_=d.isPitched===!0||d.hasPitchedItem===!0;return g&&_?(console.log(`🗑️ Removing pitched boss run: ${d.boss} ${d.difficulty} for ${t}`),!1):!0}),h=new Date().toISOString(),i={timestamp:h,action:"purge_pitched_records",character:t,characterIdx:e,itemsRemoved:a.length-u.length,bossRunsRemoved:o.length-f.length,userAgent:typeof navigator<"u"?navigator.userAgent:"Server"},y={...s,boss_runs:f,lastUpdated:h,pitched_reset_history:[...s.pitched_reset_history||[],i].slice(-50)},{error:m}=await c.from("user_data").update({pitched_items:u,data:y}).eq("id",r);if(m)throw console.error("Database update error:",m),m;return console.log(`✅ Pitched records purged successfully for ${t}`),console.log(`📊 Removed ${i.itemsRemoved} pitched items and ${i.bossRunsRemoved} boss runs`),console.log(`📊 Preserved ${f.length} non-pitched boss runs`),{success:!0,audit:i,itemsRemoved:i.itemsRemoved,bossRunsRemoved:i.bossRunsRemoved,bossRunsPreserved:f.length}}catch(c){return console.error("Error purging pitched records:",c),{success:!1,error:c.message||"Unknown error occurred"}}}async function ne(r){var t;try{if(!r)return{success:!1,error:"User code is required"};const e=await S(),{data:c,error:n}=await e.from("user_data").select("data").eq("id",r).single();if(n)throw console.error("Error fetching audit history:",n),n;const s=(((t=c.data)==null?void 0:t.pitched_reset_history)||[]).sort((a,o)=>new Date(o.timestamp)-new Date(a.timestamp));return{success:!0,history:s,totalResets:s.length}}catch(e){return console.error("Error getting pitched reset audit history:",e),{success:!1,error:e.message||"Unknown error occurred"}}}function ce(r,t,e,c){const n={...r};return Object.keys(n).forEach(l=>{l.startsWith(`${t}-${e}__`)&&l.endsWith(`__${c}`)&&(console.log(`🗑️ Clearing UI checkmark: ${l}`),delete n[l])}),n}async function ie(r){try{if(!r)return console.log("No user code provided for getAvailableWeeks"),{success:!1,error:"No user code provided"};const t=await S(),{data:e,error:c}=await t.from("user_data").select("data, pitched_items").eq("id",r).single();if(c)return console.error("Error fetching user data for available weeks:",c),{success:!1,error:c.message};const n=new Set,l=C();n.add(l),e.pitched_items&&Array.isArray(e.pitched_items)&&e.pitched_items.forEach(a=>{a.weekKey&&n.add(a.weekKey)}),e.data&&e.data.boss_runs&&Array.isArray(e.data.boss_runs)&&e.data.boss_runs.forEach(a=>{a.weekKey&&n.add(a.weekKey)}),e.data&&e.data.weekKey&&n.add(e.data.weekKey);const s=Array.from(n).sort((a,o)=>{const[u,f]=a.split("-").map(Number),[h,i]=o.split("-").map(Number);return u!==h?u-h:f-i});return console.log(`Found ${s.length} weeks with data:`,s),{success:!0,weeks:s,currentWeek:l,oldestWeek:s.length>0?s[0]:l,newestWeek:s.length>0?s[s.length-1]:l}}catch(t){return console.error("Error in getAvailableWeeks:",t),{success:!1,error:t.message}}}async function le(r){try{if(console.log(`🗑️ Starting complete stats reset for user: ${r}`),!r)return console.error("Missing required field: userCode"),{success:!1,error:"Missing required field: userCode"};const t=await S(),{data:e,error:c}=await t.from("user_data").select("data, pitched_items").eq("id",r).single();if(c)throw console.error("Error fetching user data:",c),c;const n=e.data||{},l=e.pitched_items||[],s=n.boss_runs||[],a=new Date().toISOString(),o={timestamp:a,action:"complete_stats_reset",itemsRemoved:l.length,bossRunsRemoved:s.length,userAgent:typeof navigator<"u"?navigator.userAgent:"Server"},u={...n,boss_runs:[],lastUpdated:a,pitched_reset_history:[...n.pitched_reset_history||[],o].slice(-50)},{error:f}=await t.from("user_data").update({pitched_items:[],data:u}).eq("id",r);if(f)throw console.error("Database update error:",f),f;return console.log(`✅ Complete stats reset successful for user ${r}`),console.log(`📊 Removed ${o.itemsRemoved} pitched items and ${o.bossRunsRemoved} boss runs`),{success:!0,audit:o,itemsRemoved:o.itemsRemoved,bossRunsRemoved:o.bossRunsRemoved}}catch(t){return console.error("Error in complete stats reset:",t),{success:!1,error:t.message||"Unknown error occurred"}}}async function de(r,t){try{if(console.log("saveBatchBossRuns called with:",{userCode:r,count:t.length}),!r||!Array.isArray(t)||t.length===0)return console.error("Invalid parameters for batch boss runs"),{success:!1,error:"Invalid parameters"};for(const i of t){const{character:y,characterIdx:m,bossName:d,bossDifficulty:g,isCleared:_,date:R}=i;if(!y||!d||!g||_===void 0)return console.error("Missing required fields in batch entry:",i),{success:!1,error:"Missing required fields in batch entry"}}const e=await S(),{data:c,error:n}=await e.from("user_data").select("*").eq("id",r).single();if(n)throw console.error("Error fetching user data for batch update:",n),n;if(!c)throw console.error("No user data found for batch update"),new Error("No user data found");const l=c.data?JSON.parse(JSON.stringify(c.data)):{};(!l.boss_runs||!Array.isArray(l.boss_runs))&&(l.boss_runs=[],console.log("Initializing boss_runs array for batch update"));const s=[...l.boss_runs],a=C();console.log(`Starting batch update with ${s.length} existing boss runs`);let o=[...s];for(const i of t){const{character:y,characterIdx:m,bossName:d,bossDifficulty:g,isCleared:_,date:R}=i,b=o.findIndex(D=>D.character===y&&D.boss===d&&D.difficulty===g&&D.weekKey===a);if(_){const D={id:`${y}-${d}-${g}-${a}-${Date.now()}`,character:y,characterIdx:m||0,boss:d,difficulty:g,cleared:!0,date:R||new Date().toISOString(),weekKey:a};b!==-1?(o[b]={...o[b],cleared:!0,date:R||new Date().toISOString(),lastUpdated:new Date().toISOString()},console.log(`Batch: Updating existing boss run for ${d} ${g}`)):(o.push(D),console.log(`Batch: Adding new boss run for ${d} ${g}`))}else b!==-1&&(o=o.filter((D,v)=>v!==b),console.log(`Batch: Removing boss run for ${d} ${g}`))}const u={...l,boss_runs:o,lastUpdated:new Date().toISOString()};console.log(`Batch update: ${s.length} → ${o.length} boss runs`);const{data:f,error:h}=await e.from("user_data").update({data:u}).eq("id",r).select();if(h)throw console.error("Batch database update error:",h),h;return console.log(`✅ Batch boss runs update successful: ${t.length} operations completed`),{success:!0,updatedCount:t.length,totalBossRuns:o.length}}catch(e){return console.error("Error in saveBatchBossRuns:",e),{success:!1,error:e.message}}}async function ue(r){try{if(!r)return console.log("No user code provided for getHistoricalWeekAnalysis"),{success:!1,error:"No user code provided"};console.log("🔍 Analyzing historical week data for user:",r);const t=await S(),{data:e,error:c}=await t.from("user_data").select("data, pitched_items").eq("id",r).single();if(c)return console.error("Error fetching user data for historical analysis:",c),{success:!1,error:c.message};const n=C();console.log("📅 Current week:",n),console.log("📊 Raw user data:",{pitchedItemsCount:e.pitched_items?e.pitched_items.length:0,bossRunsCount:e.data&&e.data.boss_runs?e.data.boss_runs.length:0});const l=new Set;e.pitched_items&&Array.isArray(e.pitched_items)?(console.log("🔍 Checking pitched_items for historical weeks..."),e.pitched_items.forEach((i,y)=>{console.log(`  Item ${y}:`,{weekKey:i.weekKey,character:i.character,boss:i.boss,item:i.item,isCurrentWeek:i.weekKey===n}),i.weekKey&&i.weekKey!==n&&(l.add(i.weekKey),console.log(`    ✅ Added historical week: ${i.weekKey}`))})):console.log("❌ No pitched_items found or not an array"),e.data&&e.data.boss_runs&&Array.isArray(e.data.boss_runs)?(console.log("🔍 Checking boss_runs for historical weeks..."),e.data.boss_runs.forEach((i,y)=>{console.log(`  Run ${y}:`,{weekKey:i.weekKey,character:i.character,boss:i.boss,isCurrentWeek:i.weekKey===n}),i.weekKey&&i.weekKey!==n&&(l.add(i.weekKey),console.log(`    ✅ Added historical week: ${i.weekKey}`))})):console.log("❌ No boss_runs found or not an array"),console.log("📋 Found historical weeks:",Array.from(l));const s=Array.from(l).sort((i,y)=>{const m=_=>{const R=_.split("-");return R.length===2?{year:parseInt(R[0]),week:parseInt(R[1])}:R.length===3?{year:parseInt(R[0]),week:parseInt(R[1])}:{year:0,week:0}},d=m(i),g=m(y);return d.year!==g.year?d.year-g.year:d.week-g.week}),a=s.length>0;let o=null,u="new",f=8;if(a){o=s[0];const{getWeekOffset:i}=await q(async()=>{const{getWeekOffset:d}=await import("./Navbar-C88T-MOZ.js").then(g=>g.w);return{getWeekOffset:d}},__vite__mapDeps([3,4,5,2,6,1,7])),y=i(o),m=Math.abs(y);m>8?(u="existing",f=m,console.log(`📊 Existing user detected: ${m} weeks of history, adaptive limit: ${f}`)):(u="new",console.log(`📊 New user detected: ${m} weeks of history, standard limit: ${f}`))}const h={success:!0,hasHistoricalData:a,oldestHistoricalWeek:o,historicalWeeks:s,totalHistoricalWeeks:s.length,userType:u,adaptiveWeekLimit:f,currentWeek:n,analysis:{pitchedItemsCount:e.pitched_items?e.pitched_items.length:0,bossRunsCount:e.data&&e.data.boss_runs?e.data.boss_runs.length:0,weeksWithData:s.length+1}};return console.log("📈 Historical week analysis result:",{userType:h.userType,hasHistoricalData:h.hasHistoricalData,oldestWeek:h.oldestHistoricalWeek,adaptiveLimit:h.adaptiveWeekLimit,totalWeeks:h.totalHistoricalWeeks}),h}catch(t){return console.error("Error in getHistoricalWeekAnalysis:",t),{success:!1,error:t.message}}}async function fe(r,t){try{if(console.log("🧹 PITCHED: Starting orphaned pitched items cleanup..."),!r||!Array.isArray(t))return console.error("Invalid parameters for pitched items cleanup"),{success:!1,error:"Invalid parameters"};const e=await S(),{data:c,error:n}=await e.from("user_data").select("pitched_items").eq("id",r).single();if(n)return console.error("Error fetching pitched items for cleanup:",n),{success:!1,error:n.message};const l=c.pitched_items||[];if(l.length===0)return console.log("🧹 PITCHED: No pitched items to clean up"),{success:!0,itemsRemoved:0};const s=new Set;t.forEach((o,u)=>{var f;(f=o.bosses)==null||f.forEach(h=>{const i=`${o.name}-${u}-${h.name}-${h.difficulty}`;s.add(i)})}),console.log("🧹 PITCHED: Valid boss combinations:",Array.from(s));const a=l.filter(o=>{const u=`${o.character}-${o.characterIdx||0}-${o.boss}-${o.difficulty||"Unknown"}`,f=s.has(u);return f||console.log(`🗑️ PITCHED: Removing orphaned pitched item: ${o.character} - ${o.boss} - ${o.item}`),f});if(a.length!==l.length){const{error:o}=await e.from("user_data").update({pitched_items:a}).eq("id",r);if(o)return console.error("Error updating pitched items:",o),{success:!1,error:o.message};const u=l.length-a.length;return console.log(`✅ PITCHED: Cleaned up pitched items: ${l.length} → ${a.length} (removed ${u})`),{success:!0,itemsRemoved:u}}else return console.log("🧹 PITCHED: No pitched items cleanup needed"),{success:!0,itemsRemoved:0}}catch(e){return console.error("Error in cleanupOrphanedPitchedItems:",e),{success:!1,error:e.message||"Unknown error occurred"}}}export{fe as cleanupOrphanedPitchedItems,ce as clearCharacterPitchedUI,re as exportUserData,ee as getAllPitchedItems,ie as getAvailableWeeks,C as getCurrentWeekKey,ue as getHistoricalWeekAnalysis,Z as getPitchedItems,ne as getPitchedResetAuditHistory,te as getYearlyPitchedStats,oe as importUserData,le as purgeAllStatsData,ae as purgePitchedRecords,se as removeManyPitchedItems,de as saveBatchBossRuns,Q as saveBossRun,X as savePitchedItem};
